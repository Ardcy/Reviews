# Reviews
大学阶段的所有知识点的汇总，也算是对保研路的一点点总结吧

[TOC]



暂时还不能够全部上传，一点点的上传，因为很多是自己的一些观点，保研还没结束，等结束了将全部上传。







### 1.C++

#### 1.请简要介绍一下STL？

STL的全称是Standard Template Library，叫做标准模版库，它提供了一些常用的数据结构和算法。

STL定义了一套概念体系，为范型程序设计提供了逻辑设计。它包括容器，迭代器，函数对象以及算法四个组成部分。

对于容器，也就是容纳、包含一堆元素的对象。分为基本容器类模版和容器适配器(stack)，你可能会对这两个概念不太清楚，简单点来说就是容器适配器是基本容器类模版的封装。

至于**迭代器**，就是泛化了的指针。

**函数对象**--一个行为类似函数的对象，对它可以像调用函数一样调用。函数对象是泛化的函数：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用

```c++
template <class T>
struct greater<T>
{
    bool operator()(const T &lhs, const T &rhs)
    {
        return lhs > rhs;
    }
};
```

这里面的`greater`就是一个函数对象。

至于算法，STL包括了比较多常用的算法，比如排序算法，交换算法等等。

下面列举几个常用的算法:

```c++
s.lower_bound(val); //返回指向首个不小于给定键的元素的迭代器
s.upper_bound(val); //返回指向首个大于给定键的元素的迭代器
```



#### 2. 介绍一下static

* 修饰普通变量的时候，改变变量的存储区域和生命周期，存储在静态区，在函数执行前就分配了空间。
* 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。
* 修饰成员变量，表示所有的对象共享同一个变量。
* 修饰成员函数表示不需要生成对象就可以访问这个函数。



#### 3.介绍一下inline

为了能够省去参数压栈、栈帧开辟与回收，结果返回的过程从而提高程序运行的速度，我们可以声明内联函数，内联函数同宏函数一样将在被调用处进行代码展开。但是某个函数是否是内联函数不是由我们说的算，而是由编译器决定的。我们只能向编译器建议，某个函数可以是内联函数(inline关键字)，但是编译器有自己的判断法则。但是内联是以代码膨胀（复制）为代价。



虚函数是可以声明为内联函数的，但是内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。



#### 4.介绍一下volatile

volatile 关键字声明的变量，每次访问时都必须从内存中取出值。不能通过编译器的优化。



#### 5.assert()

是一个宏不是函数。



#### 6.解释一下什么叫做封装、继承和多态？

**封装**就是利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能的隐藏内部的细节，只提供接口使之与外界进行交流与交互，也就是说它是不需要依赖于外界就能够完成自己的操作。

**继承**是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。是“is-a”的关系。

**多态**是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。( 派生类的功能可以被基类的方法或引用变量所调用，可以提高可扩充性和可维护性)



#### 7.面向过程和面向对象的区别是什么？

面向过程：当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法。

面向对象：当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。



问题： 洗衣机里面放有脏衣服，怎么洗干净？

**面向过程的解决方法：**

1、执行加洗衣粉方法；

2、执行加水方法；

3、执行洗衣服方法；

4、执行清洗方法；

5、 执行烘干方法；

以上就是将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。

**面向对象的解决方法：** 

1、我先弄出两个对象：“洗衣机”对象和“人”对象 

2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法” 

3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”

4、然后执行

人.加洗衣粉

人.加水 

洗衣机.洗衣服

洗衣机.清洗

洗衣机.烘干

解决同一个问题 ，面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。







### 2.数学分析

#### 1.什么是数学分析？

数学分析就是研究实数空间上的函数的连续性、可微性、（黎曼）可积性的数学分支。欲研究实数空间上的函数，必先讨论的是实数理论。在严格构造了实数理论后，我们才能讨论实数域上数列和函数的极限。紧随其后的，就是函数连续性的定义。接下来可以自然地引入导数的定义，然后开始讨论函数可微性。泰勒展开、光滑性、（实）解析函数，这是一条线；微分逆运算（不定积分）的讨论是另一条线。重新从黎曼和的极限出发，定义定积分，讨论可积性。然后是微积分基本定理，将定积分与不定积分联系起来。一元微积分结束，多元微积分本质上是以上步骤的高维推广。



#### 2.介绍一下海涅定理？

所有的抽样数列才能代表整体。



#### 4.



### 3.离散数学

#### 1.离散数学在讲什么？









### 4.计算机网络

#### 1.TCP为什么是可靠的？

* TCP的数据编号与确认

面向字节，一个字节对应一个序号。确认号表示期待下一次收到的数据中的第一个数据字节的序号。

* TCP的重传机制

每发送一个报文就对这个报文设置一次计时器。



#### 2.TCP的流量控制

* 滑动窗口
* 持续计时器，收到0窗口就启动，如果超过时间，发送一个零窗口探测报文段。



#### 3.TCP拥塞控制

* 满启动
* 拥塞避免
* 



#### 4.层次域名空间

域名分为顶级（*top-level*）、二级（*second-level*）、子域（*sub-domain*）



#### 5.域名服务器

* 根域名服务器：
* 顶级域名服务器
* 权限域名服务器
* 本地域名服务器



#### 6.域名解析过程

* 迭代查询
* 递归查询



#### 7.简介一下FTP的工作原理

* 提供文件传送的一些基本服务
* 使用TCP
* 端口号：21
* 在进行文件传输的时候，FTP的客户机和服务器之间要建立两个TCP连接，一个用于传输控制命令，成为控制连接，另一个用于实际的文件内容传输，称为数据连接。



### 5.线性代数

#### 1.线性代数在讲什么？

我们可以从两个方向来理解线性代数。

* 从线性变换的角度来看，将平面中的任意点**x**，通过矩阵**A**的作用，变换到与之对应的点**y**。连续施加两次线性变换，会得到一个新的线性变换，这就是矩阵乘法的由来。比如，**y = Ax**，**z= By**，则**z = B(Ax) = BAx**，其中**C = BA**表示由**A**和**B**复合而成的线性变换。如果**A**是方阵，则会衍生出一个概念特征值和特征向量。它表示对某些特定的**x**，经过矩阵A的作用后，不产生旋转效应，只产生拉伸，压缩，或反向，则这些特定的**x**，叫做特征向量，公式表达：**Ax =***λ***x**，则**x**表示不产生旋转效应的向量，*λ*表示伸缩比。很多现实中的问题本质上都是特征值特征向量的问题。比如，力学中的模态，人脸识别中的特征脸等等。
* 从向量的线性变换**y = Ax**，如果**y**已知，**A**给定，要求**x**，则是一个解线性方程组的问题。线性方程组可能有无数解，可能有唯一解，也可能无解，可能齐次，可能非齐次。对这些不同的情况的研究，就衍生出线性方程组的各类定理，以及线性方程组的求解方法。行列式，秩，逆矩阵，伴随矩阵等概念就出来帮我们判断。



#### 2.什么是齐次方程？

非零项的指数相等。



#### 3.什么是初等行变换？

* 替换
* 交换
* 数乘



#### 4.什么是线性代数？

至少有一个向量可以表示为其他向量的线性组合。



#### 5.求逆有哪些方法？

* 初等行变换
* 公式法



#### 6.LU分解有什么用？

用于解方程，因为是三角矩阵所以只需要回带就可以了。



#### 7.求行列式有什么方法？

* 公式法（适用于小矩阵）
* 拉普拉斯展开法
* 构造法
* 初等行变换为三角阵
* 范德蒙德行列式
* 克拉默法则



#### 8.什么是向量空间（线性空间）？

* 定义了两种运算$*,+$
* 对于加法和数乘封闭
* 满足交换律，结合律，分配律



#### 9.说一下四个基本子空间？

四个基本子空间包括列空间，行空间，零空间和左零空间



#### 10.什么是线性变换？

$T(u+v)=T(u)+T(v)$

$T(cu)=cT(u)$



#### 11.什么是基？

最小生成集。



#### 12.什么是维度？

向量空间任意基中的向量个数。



#### 13.什么是秩？

一个矩阵的列向量空间的维度。



#### 14.解释一下单射和满射？

单射是说指将不同的变量映射到不同的值的函数。

对陪域中任意元素，都存在至少一个定义域中的元素与之对应。





#### 15.什么是秩定理？

$Rank A+dim NUL A=n$



#### 16.什么是正交矩阵？

方阵且每一列都单位正交



#### 17.什么是奇异值分解？

奇异值分解是特征值分解的特例，因为特征值只有在方阵的前提下才存在，但是奇异值就对于一般矩阵也存在了。





### 6.数据结构

#### 1.数据结构在讲什么？

数据结构这门学科就是为了让计算机能够以更加高效，简单，便捷的方式来存储和使用数据而产生的。所有的目标都围绕着存和取两个目标打转。在这两个目标下，有几个评估的指标，存取效率，可扩展性，顺序性，可排序性这几个特征。

数据结构分为三大类。线性表，树和图。



线性表是为了解决单线存储而出现的。数组：就是最简单粗暴的存储方法。就是直接拉出一大块数据存在那里。数组的快速存取其实只是一个副作用，因为所有的数据都在一起，可以直接算出来数据的地址。

链表：则是为了解决可以无线增长的需求的。因为找不到一大块可以连续的存入数据，甚至也不知道程序可能使用的数据总量，所以就没办法划分一块数据来使用，划小了不够用，划大了浪费（这在早年是非常大的事情）。所以必须想办法解决问题。最后采用的方法就是从入口开始，**每一个数据块不仅仅有数据，还会有指向下一个数据块的线索，用来寻找下一个数据。**这就是链表。

所谓的双向链表，只是加了一个向前的线索的链表而已。不仅如此，队列，栈，都是线性表的特殊形态。进行了操作上的限制罢了。既可以是数组，也可以是链表。





树是为了解决单一入口下的非线性关联性的数据存储或者排序这样的功能而来的。

最常见的应用是编程时候的map，就是利用了二叉树的可排序和可以快速插入并且保持序列完整的特性来构建键值数据对，来实现数据的插入增加以及快速查找的能力的。

还有做语法解析，文字处理等等很多场景也会用到树。这就不一一赘述了。当然在吃透线性表的基础上，再去理解树也并不难。因为在本质上，树相对于链表，就是**每个节点不止有一个后续节点但是只有一个前置节点。**



图的本质其实就是把线性表进一步扩展，**每个节点会有不止一个前置和后缀节点，而且前置和后缀的概念也不再明晰，变成了关联节点**。



#### 2.介绍一下冒泡排序的过程



#### 3.介绍一下选择排序的过程。

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。



#### 4.介绍一下插入排序

- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）



#### 5.介绍一下归并排序

- 将未排序的列表划分为n个子列表，每个子列表包含一个元素（一个元素的列表被认为是排序的）。
- 反复合并子列表以产生新的排序子列表，直到只剩一个子列表。这将是排序列表。



#### 6.介绍一下快速排序

- 从数列中挑出一个元素，称为 “基准”（pivot）;
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；



* 当数组全部排好序或者数组全部是一样的数字快速排序的效率最低。



#### 7.介绍一下堆排序

- 创建堆，以数组的形式将堆中所有的数据重新排序，使其成为最大堆/最小堆。
- 调整堆，调整过程需要保证堆序性质：在一个二叉堆中任意父节点大于其子节点。
- 堆排序，取出位于堆顶的第一个数据（最大堆则为最大数，最小堆则为最小数），放入输出数组B 中，再将剩下的对作调整堆的迭代/重复运算直至输入数组 A中只剩下最后一个元素。



```C++
priority_queue<int,vector<int>,less<int> > big_heap;
priority_queue<int,vector<int>,greater<int> > small_heap;
```



#### 8.介绍一下计数排序

- 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max
- 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)
- 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数
- 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数



#### 9.介绍一下桶排序

- 设置固定数量的空桶。
- 把数据放到对应的桶中。
- 对每个不为空的桶中数据进行排序。
- 拼接不为空的桶中数据，得到结果



#### 10.介绍一下满二叉树，完全二叉树，二叉搜索树，平衡二叉树之间的区别？

完全二叉树是由满二叉树演变而来的，每个节点的按照从左到右从上到下编号，跟满二叉树是一样的。



二叉搜索树是递归定义：

若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
左、右子树也分别为二叉搜索树。



但是由于二叉搜索树会退化为链表，所以就发明了平衡二叉树。

平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。



#### 11.介绍一下先序遍历的非递归算法。

- 访问结点P
- 先看右孩子是不是空的，如果不空压栈
- 再看左孩子，如果左孩子空的话，弹出栈顶元素，否则继续左孩子深入直到所有的节点都访问到了



#### 12.介绍一下中序遍历的非递归算法

- 若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；
- 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；
- 直到P为NULL并且栈为空则遍历结束



#### 13.介绍一下后序遍历的非递归算法

要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。



#### 14.求强连通分量的基本步骤

- 对G进行深度优先遍历，生成G的深度优先生成森林T。
- 对森林T的顶点按中序遍历顺序进行编号。
- 改变G中每一条弧的方向，构成一个新的有向图G’。
- 按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度 优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一 个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该 步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点
- 重复步骤⑷ ，直到G’中的所有顶点都被访问。如下图是求一棵有向树的强连通分量过程。



#### 15.介绍一下最小生成树

* 克鲁斯卡尔 (Kruskal) 算法：每次选全局最小的
* Prime算法：设计了一个已选节点的集合，每次在已选节点所在的边选最小。



#### 16.介绍一下拓扑排序

- 在AOV网中选择一个没有前驱的顶点且输出；
- 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧) 所有有向弧(边) ；
- 直到图中全部顶点都已输出(图中无环)或图中不存 在无前驱的顶点(图中必有环)。





#### 17.求AOE中关键路径和关键活动

- 利用拓扑排序求出AOE网的一个拓扑序列；
- 从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个 事件的最早发生时间ve(i) ；
- 从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；

* 最早和最晚相等就为关键路径



#### 18.单源点最短路径

- 把图中所有顶点分成两组  
  - 第一组包括已确定最短路径的顶点； 
  - 第二组包括尚未确定最短路径的顶点； 
- 按最短路径长度递增的顺序逐个把第二组的顶点加到第一组中去
  - 直至从s出发可以到达的所有顶点都包括进第一组中。
- 在这个过程中，总保持从s到第一组各顶点的最短路径长度都不大于从s到第二组的任何顶点的最短路径长度，而且，每个顶点都对应一个距离值：
  - 第一组的顶点对应的距离值就是从s到该顶点的最短路径长度；  第二组的顶点对应的距离值是从s到该顶点的只包括第一组的顶点为中 间顶点的最短路径长度。



#### 19.Floyd算法思想

动态规划思想



#### 20.什么是线性表？

由结点集N，以及定义在结点集N上的线性关系r所组成 的线性结构，这些结点称为线性表的元素。零个或多个数据元素的有限序列。



#### 21.什么是栈和队列？

栈：限定仅在表尾进行插入和删除操作的线性表

队列：限定仅在表头进行插入和删除操作的线性表





#### 22.介绍一下递归的定义

子程序（或函数）直接调用自己或通过一系列调用语句间接调用自己，是 一种描述问题和解决问题的基本方法。



#### 23.检测一个图是否是树

* 是一个全连通图（所有节点相通）（DFS）

* 无回路（边=节点数-1）



#### 24.如何找到一个二叉树中给定节点的祖先：搜索二叉树？一般二叉树？

对于搜索二叉树而言就会简单很多。

如果都小于或者大于某个节点，递归的返回。

如果一个大一个小，就是这个节点了。





对于一般二叉树：

* 若p和q分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。
* 若p和q同时位于左子树，这里有两种情况，一种情况是 left 会返回p和q中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。
* 若p和q同时位于右子树，同样这里有两种情况，一种情况是 right 会返回p和q中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回



#### 25.如何判断一棵二叉树是不是平衡二叉树？

* 高度差<=1
* 满足搜索二叉树





#### 26.判断是不是完全二叉树

- 按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。



#### 27.求二叉树中节点的最大距离

递归解法：
（1）如果二叉树为空，返回0，同时记录左子树和右子树的深度，都为0
（2）如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点中到根节点的最大距离，同时记录左子树和右子树节点中到根节点的最大距离。





#### 28.为什么有了平衡树还需要有红黑树？

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了**红黑树**，红黑树具有如下特点：

1、具有二叉查找树的特点。

2、根节点是黑色的；

3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。

4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。

5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。至于为什么就能够保证时间复杂度为 O(logn)。

不过，与平衡树不同的是，红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。



平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

红黑树的所有操作的时间复杂度都是$O(log(n))$



#### 29.红黑树和哈希的比较？



当你想用空间换取时间的话，考虑用hash。

但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。

红黑树是有序的，Hash是无序的，根据需求来选择。
红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先应该分配足够的内存存储散列表,即使有些槽可能弃用
红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。

### 机试

#### 1.高精度整数





#### 2.并查集

##### 2.1用于克鲁斯卡尔最小生成树

使用了并查集的思想来判断新加入的边两端的结点与树相连时是否出现环。



#### 3.最短路径



#### 4.拓扑排序





























