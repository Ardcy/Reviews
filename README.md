# Reviews
大学阶段的所有知识点的汇总，也算是对保研路的一点点总结吧

[TOC]



暂时还不能够全部上传，一点点的上传，因为很多是自己的一些观点，保研还没结束，等结束了将全部上传。







### 1.C++

#### 1.请简要介绍一下STL？

STL的全称是Standard Template Library，叫做标准模版库，它提供了一些常用的数据结构和算法。

STL定义了一套概念体系，为范型程序设计提供了逻辑设计。它包括容器，迭代器，函数对象以及算法四个组成部分。

对于容器，也就是容纳、包含一堆元素的对象。分为基本容器类模版和容器适配器(stack)，你可能会对这两个概念不太清楚，简单点来说就是容器适配器是基本容器类模版的封装。

至于**迭代器**，就是泛化了的指针。

**函数对象**--一个行为类似函数的对象，对它可以像调用函数一样调用。函数对象是泛化的函数：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用

```c++
template <class T>
struct greater<T>
{
    bool operator()(const T &lhs, const T &rhs)
    {
        return lhs > rhs;
    }
};
```

这里面的`greater`就是一个函数对象。

至于算法，STL包括了比较多常用的算法，比如排序算法，交换算法等等。

下面列举几个常用的算法:

```c++
s.lower_bound(val); //返回指向首个不小于给定键的元素的迭代器
s.upper_bound(val); //返回指向首个大于给定键的元素的迭代器
```



#### 2. 介绍一下static

* 修饰普通变量的时候，改变变量的存储区域和生命周期，存储在静态区，在函数执行前就分配了空间。
* 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。
* 修饰成员变量，表示所有的对象共享同一个变量。
* 修饰成员函数表示不需要生成对象就可以访问这个函数。



#### 3.介绍一下inline

为了能够省去参数压栈、栈帧开辟与回收，结果返回的过程从而提高程序运行的速度，我们可以声明内联函数，内联函数同宏函数一样将在被调用处进行代码展开。但是某个函数是否是内联函数不是由我们说的算，而是由编译器决定的。我们只能向编译器建议，某个函数可以是内联函数(inline关键字)，但是编译器有自己的判断法则。但是内联是以代码膨胀（复制）为代价。



虚函数是可以声明为内联函数的，但是内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。



#### 4.介绍一下volatile

volatile 关键字声明的变量，每次访问时都必须从内存中取出值。不能通过编译器的优化。



#### 5.assert()

是一个宏不是函数。



#### 6.解释一下什么叫做封装、继承和多态？

**封装**就是利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能的隐藏内部的细节，只提供接口使之与外界进行交流与交互，也就是说它是不需要依赖于外界就能够完成自己的操作。

**继承**是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。是“is-a”的关系。

**多态**是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。( 派生类的功能可以被基类的方法或引用变量所调用，可以提高可扩充性和可维护性)



#### 7.面向过程和面向对象的区别是什么？

面向过程：当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法。

面向对象：当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。



问题： 洗衣机里面放有脏衣服，怎么洗干净？

**面向过程的解决方法：**

1、执行加洗衣粉方法；

2、执行加水方法；

3、执行洗衣服方法；

4、执行清洗方法；

5、 执行烘干方法；

以上就是将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。

**面向对象的解决方法：** 

1、我先弄出两个对象：“洗衣机”对象和“人”对象 

2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法” 

3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”

4、然后执行

人.加洗衣粉

人.加水 

洗衣机.洗衣服

洗衣机.清洗

洗衣机.烘干

解决同一个问题 ，面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。







### 2.数学分析

#### 1.什么是数学分析？

数学分析就是研究实数空间上的函数的连续性、可微性、（黎曼）可积性的数学分支。欲研究实数空间上的函数，必先讨论的是实数理论。在严格构造了实数理论后，我们才能讨论实数域上数列和函数的极限。紧随其后的，就是函数连续性的定义。接下来可以自然地引入导数的定义，然后开始讨论函数可微性。泰勒展开、光滑性、（实）解析函数，这是一条线；微分逆运算（不定积分）的讨论是另一条线。重新从黎曼和的极限出发，定义定积分，讨论可积性。然后是微积分基本定理，将定积分与不定积分联系起来。一元微积分结束，多元微积分本质上是以上步骤的高维推广。



#### 2.你觉得数学分析当中最重要的一个定理是什么？

我认为是微积分基本定理。

一个重要的定理往往体现它能不能勾连不同的概念，是不是能在不同的定理间架起桥梁。这个定理勾连了微分和积分，这两个微积分最基本的概念。虽然现在几乎每个理科本科生都知道积分和微分是相互联系的的，微分和积分的基本思路在古希腊都已经存在了，但是很长的时间内学者并没有意识到它们的关系。微积分的难点不在于其「思想」，在于如何数学化和严格化它。一直到牛顿和莱布尼兹才刚刚开始数学化。严格化则要到Cauchy和威尔斯托拉斯。

重要的定理还有一个特征，大家热衷于推广它。微积分基本定理有多种推广形式，而且每一种推广都影响深远，比如把右侧的黎曼积分换成勒贝格积分，这个就会和绝对连续函数产生关系。比如它推广到多维后是格林公式，是高斯公式，更是斯托克斯公式。推广到微分形式后获得一个非常漂亮的stokes formula. 



#### 3.介绍一下海涅定理？

所有的抽样数列才能代表整体。



#### 4.间断点的分类？

* 第一类间断点
  * 可去间断点(左右极限相等)例子：分段函数
  * 跳跃间断点(左右极限不相等)例子：$y=\frac{|x|}{x}$在$x=0$处
* 第二类间断点(左右极限至少有一个不存在) )例子：$t=\tan x$在$x=\pi/2$处



#### 5.说出实数系的定理

* 戴的金连续性定理
* 区间套定理
* 单调有界收敛
* 确界定理
* 紧致性定理
* 柯西收敛准则
* 有限覆盖



#### 6.介值定理指什么？



#### 7.什么是康托定理？

在闭区间上连续的函数在该闭区间一致连续。



#### 8.连续？



#### 9.一致连续？









### 3.离散数学

#### 1.离散数学在讲什么？









### 4.计算机网络

#### 1.TCP为什么是可靠的？

* TCP的数据编号与确认

面向字节，一个字节对应一个序号。确认号表示期待下一次收到的数据中的第一个数据字节的序号。

* TCP的重传机制

每发送一个报文就对这个报文设置一次计时器。



#### 2.TCP的流量控制

* 滑动窗口
* 持续计时器，收到0窗口就启动，如果超过时间，发送一个零窗口探测报文段。



#### 3.TCP拥塞控制

* 满启动
* 拥塞避免
* 



#### 4.层次域名空间

域名分为顶级（*top-level*）、二级（*second-level*）、子域（*sub-domain*）



#### 5.域名服务器

* 根域名服务器：
* 顶级域名服务器
* 权限域名服务器
* 本地域名服务器



#### 6.域名解析过程

* 迭代查询
* 递归查询



#### 7.简介一下FTP的工作原理

* 提供文件传送的一些基本服务
* 使用TCP
* 端口号：21
* 在进行文件传输的时候，FTP的客户机和服务器之间要建立两个TCP连接，一个用于传输控制命令，成为控制连接，另一个用于实际的文件内容传输，称为数据连接。



### 5.线性代数

#### 1.线性代数在讲什么？

我们可以从两个方向来理解线性代数。

* 从线性变换的角度来看，将平面中的任意点**x**，通过矩阵**A**的作用，变换到与之对应的点**y**。连续施加两次线性变换，会得到一个新的线性变换，这就是矩阵乘法的由来。比如，**y = Ax**，**z= By**，则**z = B(Ax) = BAx**，其中**C = BA**表示由**A**和**B**复合而成的线性变换。如果**A**是方阵，则会衍生出一个概念特征值和特征向量。它表示对某些特定的**x**，经过矩阵A的作用后，不产生旋转效应，只产生拉伸，压缩，或反向，则这些特定的**x**，叫做特征向量，公式表达：**Ax =***λ***x**，则**x**表示不产生旋转效应的向量，*λ*表示伸缩比。很多现实中的问题本质上都是特征值特征向量的问题。比如，力学中的模态，人脸识别中的特征脸等等。
* 从向量的线性变换**y = Ax**，如果**y**已知，**A**给定，要求**x**，则是一个解线性方程组的问题。线性方程组可能有无数解，可能有唯一解，也可能无解，可能齐次，可能非齐次。对这些不同的情况的研究，就衍生出线性方程组的各类定理，以及线性方程组的求解方法。行列式，秩，逆矩阵，伴随矩阵等概念就出来帮我们判断。



#### 2.什么是齐次方程？

非零项的指数相等。



#### 3.什么是初等行变换？

* 替换
* 交换
* 数乘



#### 4.什么是线性代数？

至少有一个向量可以表示为其他向量的线性组合。



#### 5.求逆有哪些方法？

* 初等行变换
* 公式法



#### 6.LU分解有什么用？

用于解方程，因为是三角矩阵所以只需要回带就可以了。



#### 7.求行列式有什么方法？

* 公式法（适用于小矩阵）
* 拉普拉斯展开法
* 构造法
* 初等行变换为三角阵
* 范德蒙德行列式
* 克拉默法则



#### 8.什么是向量空间（线性空间）？

* 定义了两种运算$*,+$
* 对于加法和数乘封闭
* 满足交换律，结合律，分配律



#### 9.说一下四个基本子空间？

四个基本子空间包括列空间，行空间，零空间和左零空间



#### 10.什么是线性变换？

$T(u+v)=T(u)+T(v)$

$T(cu)=cT(u)$



#### 11.什么是基？

最小生成集。



#### 12.什么是维度？

向量空间任意基中的向量个数。



#### 13.什么是秩？

一个矩阵的列向量空间的维度。



#### 14.解释一下单射和满射？

单射是说指将不同的变量映射到不同的值的函数。

对陪域中任意元素，都存在至少一个定义域中的元素与之对应。





#### 15.什么是秩定理？

$Rank A+dim NUL A=n$



#### 16.什么是正交矩阵？

方阵且每一列都单位正交



#### 17.什么是奇异值分解？

奇异值分解是特征值分解的特例，因为特征值只有在方阵的前提下才存在，但是奇异值就对于一般矩阵也存在了。





### 6.数据结构

#### 1.数据结构在讲什么？

数据结构这门学科就是为了让计算机能够以更加高效，简单，便捷的方式来存储和使用数据而产生的。所有的目标都围绕着存和取两个目标打转。在这两个目标下，有几个评估的指标，存取效率，可扩展性，顺序性，可排序性这几个特征。

数据结构分为三大类。线性表，树和图。



线性表是为了解决单线存储而出现的。数组：就是最简单粗暴的存储方法。就是直接拉出一大块数据存在那里。数组的快速存取其实只是一个副作用，因为所有的数据都在一起，可以直接算出来数据的地址。

链表：则是为了解决可以无线增长的需求的。因为找不到一大块可以连续的存入数据，甚至也不知道程序可能使用的数据总量，所以就没办法划分一块数据来使用，划小了不够用，划大了浪费（这在早年是非常大的事情）。所以必须想办法解决问题。最后采用的方法就是从入口开始，**每一个数据块不仅仅有数据，还会有指向下一个数据块的线索，用来寻找下一个数据。**这就是链表。

所谓的双向链表，只是加了一个向前的线索的链表而已。不仅如此，队列，栈，都是线性表的特殊形态。进行了操作上的限制罢了。既可以是数组，也可以是链表。





树是为了解决单一入口下的非线性关联性的数据存储或者排序这样的功能而来的。

最常见的应用是编程时候的map，就是利用了二叉树的可排序和可以快速插入并且保持序列完整的特性来构建键值数据对，来实现数据的插入增加以及快速查找的能力的。

还有做语法解析，文字处理等等很多场景也会用到树。这就不一一赘述了。当然在吃透线性表的基础上，再去理解树也并不难。因为在本质上，树相对于链表，就是**每个节点不止有一个后续节点但是只有一个前置节点。**



图的本质其实就是把线性表进一步扩展，**每个节点会有不止一个前置和后缀节点，而且前置和后缀的概念也不再明晰，变成了关联节点**。



#### 2.介绍一下冒泡排序的过程



#### 3.介绍一下选择排序的过程。

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。



#### 4.介绍一下插入排序

- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）



#### 5.介绍一下归并排序

- 将未排序的列表划分为n个子列表，每个子列表包含一个元素（一个元素的列表被认为是排序的）。
- 反复合并子列表以产生新的排序子列表，直到只剩一个子列表。这将是排序列表。



#### 6.介绍一下快速排序

- 从数列中挑出一个元素，称为 “基准”（pivot）;
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；



* 当数组全部排好序或者数组全部是一样的数字快速排序的效率最低。



#### 7.介绍一下堆排序

- 创建堆，以数组的形式将堆中所有的数据重新排序，使其成为最大堆/最小堆。
- 调整堆，调整过程需要保证堆序性质：在一个二叉堆中任意父节点大于其子节点。
- 堆排序，取出位于堆顶的第一个数据（最大堆则为最大数，最小堆则为最小数），放入输出数组B 中，再将剩下的对作调整堆的迭代/重复运算直至输入数组 A中只剩下最后一个元素。



```C++
priority_queue<int,vector<int>,less<int> > big_heap;
priority_queue<int,vector<int>,greater<int> > small_heap;
```



#### 8.介绍一下计数排序

- 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max
- 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)
- 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数
- 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数



#### 9.介绍一下桶排序

- 设置固定数量的空桶。
- 把数据放到对应的桶中。
- 对每个不为空的桶中数据进行排序。
- 拼接不为空的桶中数据，得到结果



#### 10.介绍一下满二叉树，完全二叉树，二叉搜索树，平衡二叉树之间的区别？

完全二叉树是由满二叉树演变而来的，每个节点的按照从左到右从上到下编号，跟满二叉树是一样的。



二叉搜索树是递归定义：

若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
左、右子树也分别为二叉搜索树。



但是由于二叉搜索树会退化为链表，所以就发明了平衡二叉树。

平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。



#### 11.介绍一下先序遍历的非递归算法。

- 访问结点P
- 先看右孩子是不是空的，如果不空压栈
- 再看左孩子，如果左孩子空的话，弹出栈顶元素，否则继续左孩子深入直到所有的节点都访问到了



#### 12.介绍一下中序遍历的非递归算法

- 若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；
- 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；
- 直到P为NULL并且栈为空则遍历结束



#### 13.介绍一下后序遍历的非递归算法

要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。



#### 14.求强连通分量的基本步骤

- 对G进行深度优先遍历，生成G的深度优先生成森林T。
- 对森林T的顶点按中序遍历顺序进行编号。
- 改变G中每一条弧的方向，构成一个新的有向图G’。
- 按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度 优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一 个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该 步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点
- 重复步骤⑷ ，直到G’中的所有顶点都被访问。如下图是求一棵有向树的强连通分量过程。



#### 15.介绍一下最小生成树

* 克鲁斯卡尔 (Kruskal) 算法：每次选全局最小的
* Prime算法：设计了一个已选节点的集合，每次在已选节点所在的边选最小。



#### 16.介绍一下拓扑排序

- 在AOV网中选择一个没有前驱的顶点且输出；
- 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧) 所有有向弧(边) ；
- 直到图中全部顶点都已输出(图中无环)或图中不存 在无前驱的顶点(图中必有环)。





#### 17.求AOE中关键路径和关键活动

- 利用拓扑排序求出AOE网的一个拓扑序列；
- 从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个 事件的最早发生时间ve(i) ；
- 从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；

* 最早和最晚相等就为关键路径



#### 18.单源点最短路径

- 把图中所有顶点分成两组
  - 第一组包括已确定最短路径的顶点
  - 第二组包括尚未确定最短路径的顶点； 
- 按最短路径长度递增的顺序逐个把第二组的顶点加到第一组中去
  - 直至从s出发可以到达的所有顶点都包括进第一组中。
- 在这个过程中，总保持从s到第一组各顶点的最短路径长度都不大于从s到第二组的任何顶点的最短路径长度，而且，每个顶点都对应一个距离值：
  * 第一组的顶点对应的距离值就是从s到该顶点的最短路径长度，第二组的顶点对应的距离值是从s到该顶点的只包括第一组的顶点为中 间顶点的最短路径长度。



#### 19.Floyd算法思想

动态规划思想



#### 20.什么是线性表？

由结点集N，以及定义在结点集N上的线性关系r所组成 的线性结构，这些结点称为线性表的元素。零个或多个数据元素的有限序列。



#### 21.什么是栈和队列？

栈：限定仅在表尾进行插入和删除操作的线性表

队列：限定仅在表头进行插入和删除操作的线性表





#### 22.介绍一下递归的定义

子程序（或函数）直接调用自己或通过一系列调用语句间接调用自己，是 一种描述问题和解决问题的基本方法。



#### 23.检测一个图是否是树

* 是一个全连通图（所有节点相通）（DFS）

* 无回路（边=节点数-1）



#### 24.如何找到一个二叉树中给定节点的祖先：搜索二叉树？一般二叉树？

对于搜索二叉树而言就会简单很多。

如果都小于或者大于某个节点，递归的返回。

如果一个大一个小，就是这个节点了。





对于一般二叉树：

* 若p和q分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。
* 若p和q同时位于左子树，这里有两种情况，一种情况是 left 会返回p和q中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。
* 若p和q同时位于右子树，同样这里有两种情况，一种情况是 right 会返回p和q中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回



#### 25.如何判断一棵二叉树是不是平衡二叉树？

* 高度差<=1
* 满足搜索二叉树





#### 26.判断是不是完全二叉树

- 按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。



#### 27.求二叉树中节点的最大距离

递归解法：
（1）如果二叉树为空，返回0，同时记录左子树和右子树的深度，都为0
（2）如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点中到根节点的最大距离，同时记录左子树和右子树节点中到根节点的最大距离。





#### 28.为什么有了平衡树还需要有红黑树？

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了**红黑树**，红黑树具有如下特点：

1、具有二叉查找树的特点。

2、根节点是黑色的；

3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。

4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。

5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。至于为什么就能够保证时间复杂度为 O(logn)。

不过，与平衡树不同的是，红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。



平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

红黑树的所有操作的时间复杂度都是$O(log(n))$



#### 29.红黑树和哈希的比较？



当你想用空间换取时间的话，考虑用hash。

但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。

红黑树是有序的，Hash是无序的，根据需求来选择。
红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先应该分配足够的内存存储散列表,即使有些槽可能弃用
红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。







### 7.操作系统

#### 1.什么是操作系统？

操作系统核心即怎么虚拟多几个冯诺依曼计算机出来给程序用。 操作系统是控制应用程序执行的程序，是应用程序和计算机硬件间的接口(屏蔽硬件细节)。



#### 2.操作系统的发展历程？

串行处理->简单批处理->多道批处理->分时系统->实时系统**（在特定时间内必须完成任务的执行）**



#### 3.操作系统涉及的几个方面的管理？

进程管理、内存管理、文件管理、设备管理



#### 4.进程和程序的区别？

进程是运行中的程序的实例！



#### 5.我们通常所说的64位和32位指的是什么？

cpu,操作系统,进程都会存在这些说法。







#### 6.进程映像包括哪些内容？

进程控制块PCB（用于进程控制于调度）、程序段和相关数据段（用于运行程序）、系统栈（跟踪过程调用及参数传递）、共享地址空间（进程间通信）。



#### 7.什么是进程同步？

是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。



#### 8.进程的通信方式有哪些？

* 共享存储器系统
  * 对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。
* 消息传递系统
  * 进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。
* 管道通信系统
  * 管道即：连接读写进程以实现他们之间通信的共享文件
  * 管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。



#### 9.进程和线程的区别有哪些？

（1）进程有自己的独立地址空间，线程没有

（2）进程是资源分配的最小单位，线程是CPU调度的最小单位

（3）进程和线程通信方式不同(线程之间的通信比较方便。同一进程下的线程共享数据		（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何			处理	好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信			只能通过进程通信的方式进行。

（4）进程上下文切换开销大，线程开销小

（5）一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程

（6）对进程进程操作一般开销都比较大，对线程开销就小了 



#### 10.为什么进程上下文切换比线程上下文切换代价高？

进程切换分两步：

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。



#### 11.进程的调度类型

- **高级调度**：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
- **低级调度**：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；
- **中级调度**：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。



#### 12.调度算法

* First Come, First Served (FCFS)先来先服务
  * 调度的顺序就是任务到达就绪队列的顺序。
  * 公平、简单(FIFO队列)、非抢占、不适合交互式。
  * 未考虑任务特性，平均等待时间可以缩短。
* Shortest Job First (SJF)
  * SJF可以保证最小的平均等待时间。
* 优先权调度
  * 优先级低的进程可能会出现“饥饿”现象。

* Round-Robin(RR)轮转调度算法
  * 上下文切换次数较多
* 多级反馈队列
  * **在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。**
  * **可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。**
  * **最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。**



#### 13.死锁产生的条件？如何处理死锁？

**定义**:如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,那么该组进程就是死锁的。



产生死锁的必要条件：

- **互斥条件(Mutual exclusion)**：资源不能被共享，只能由一个进程使用。
- **请求与保持条件(Hold and wait)**：已经得到资源的进程可以再次申请新的资源。
- **非抢占条件(No pre-emption)**：已经分配的资源不能从相应的进程中被强制地剥夺。
- **循环等待条件(Circular wait)**：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。



**如何处理死锁问题：**

- **忽略该问题**。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
- **检测死锁并且恢复。**
- 仔细地对资源进行动态分配，使系统始终处于安全状态以**避免死锁**。
- **通过破除死锁四个必要条件之一，来防止死锁产生。**



#### 14.一个程序从开始运行到结束的完整过程

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

3、汇编：汇编变为目标代码(机器代码)生成.o的文件

4、链接：连接目标代码,生成可执行程序



#### 15.动态链接库与静态链接库的区别

* 静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。

* 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：    假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

  

  

  

  

  

  

#### 16.介绍一下虚拟内存。

在虚拟内存没有出现的时候一个进程要运行，必须保证其全部载入内存，这样会对并发产生很大的影响，于是我们设计了虚拟内存，无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。同时虚拟内存也从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。



#### 17.介绍一下页面置换算法

* 先进先出页面置换算法
* 最近最少使用页面置换算法LRU



#### 18.介绍一下逻辑地址、物理地址和虚拟地址

- 所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。**例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，**逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维**。
- 另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，**操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展**。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。**虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。**这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。现代计算机中有一个专门的**转译缓冲区(Translation Lookaside Buffer，TLB)**，用来实现虚拟地址到物理地址的快速转换。



#### 19.介绍一下内部碎片和外部碎片

在内存管理中，**内部碎片**是已经被分配出去的的内存空间大于请求所需的内存空间。

**外部碎片**是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。

固定分区存在内部碎片，可变式分区分配会存在外部碎片；

**页式虚拟存储**系统存在**内部碎片**；**段式虚拟存储**系统，存在**外部碎片**



#### 20.系统调用与库函数的区别

* 系统调用(System call)是程序向系统内核请求服务的方式。**可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。
* **库函数：把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间**。







### 机试

#### 1.高精度整数





#### 2.并查集

##### 2.1用于克鲁斯卡尔最小生成树

使用了并查集的思想来判断新加入的边两端的结点与树相连时是否出现环。



#### 3.最短路径



#### 4.拓扑排序





























